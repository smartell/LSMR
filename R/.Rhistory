# This a simple R-script to test the Punt et al (1997) paper.#
#
#
# vonB growth parameters#
dt		<- 1/4#
a		<- seq(0, 30, dt)#
linf	<- 150#
k		<- 0.3#
#
len 	<- linf*(1-exp(-k*a))#
plot(a, len, type="l")#
#
#
# reference lengths#
l1 <- 80#
l2 <- 100#
lam1 <- l1 + (linf-l1)*(1-exp(-k))#
lam2 <- l2 + (linf-l2)*(1-exp(-k))
abline(h=c(l2,l2))
abline(h=c(l1,l2))
abline(h=c(lam1,lam2))
abline(h=c(lam1,lam2),col=2)
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
# This a simple R-script to test the Punt et al (1997) paper.#
#
#
# vonB growth parameters#
dt		<- 1/4#
a		<- seq(0, 30, dt)#
linf	<- 150#
k		<- 0.3#
#
len 	<- linf*(1-exp(-k*a))#
plot(a, len, type="o")#
#
#
# reference lengths#
l1 <- 80#
l2 <- 100#
lam1 <- l1 + (linf-l1)*(1-exp(-k))#
lam2 <- l2 + (linf-l2)*(1-exp(-k))
abline(h=c(l1,l2))
abline(h=c(lam1,lam2),col=2)
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
# This a simple R-script to test the Punt et al (1997) paper.#
#
#
# vonB growth parameters#
dt		<- 1/4#
a		<- seq(0, 30, dt)#
linf	<- 150#
k		<- 0.3#
#
len 	<- linf*(1-exp(-k*a))#
plot(a, len, type="o")#
#
#
# reference lengths#
l1 <- 80#
l2 <- 100#
lam1 <- l1 + (linf-l1)*(1-exp(-k*dt))#
lam2 <- l2 + (linf-l2)*(1-exp(-k*dt))
abline(h=c(l1,l2))
abline(h=c(lam1,lam2),col=2)
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
# This a simple R-script to test the Punt et al (1997) paper.#
#
#
# vonB growth parameters#
dt		<- 1/4#
da		<- seq(0, 30, dt)#
linf	<- 150#
k		<- 0.3#
#
len 	<- linf*(1-exp(-k*da))#
plot(da, len, type="o")#
#
#
# equivalent parameters for the generalized Schnute model.#
c	<- 1#
l1	<- 80#
l2	<- 100#
lam1	<- l1 + (linf-l1)*(1-exp(-k*dt))#
lam2	<- l2 + (linf-l2)*(1-exp(-k*dt))
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
# This a simple R-script to test the Punt et al (1997) paper.#
#
#
# vonB growth parameters#
dt		<- 1/4#
da		<- seq(0, 30, dt)#
linf	<- 150#
k		<- 0.3#
#
len 	<- linf*(1-exp(-k*da))#
plot(da, len, type="o")#
#
#
# equivalent parameters for the generalized Schnute model.#
c	<- 1#
l1	<- 80#
l2	<- 100#
lam1	<- l1 + (linf-l1)*(1-exp(-k*dt))#
lam2	<- l2 + (linf-l2)*(1-exp(-k*dt))#
#
a	<- (l2^c-l1^c)/(lam2^c-lam1^c)
a
exp(k)
exp(-k)
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
# This a simple R-script to test the Punt et al (1997) paper.#
#
#
# vonB growth parameters#
dt		<- 1/4#
da		<- seq(0, 30, dt)#
linf	<- 150#
k		<- 0.3#
#
len 	<- linf*(1-exp(-k*da))#
plot(da, len, type="o")#
#
#
# equivalent parameters for the generalized Schnute model.#
c	<- 1#
l1	<- 80#
l2	<- 100#
lam1	<- l1 + (linf-l1)*(1-exp(-k*dt))#
lam2	<- l2 + (linf-l2)*(1-exp(-k*dt))#
#
a	<- (l2^c-l1^c)/(lam2^c-lam1^c)#
b	<- (lam1^c*l2^c - l1^c*lam2^c) / (lam1^c-l1^c+l2^c-lam2^c)
b
a
k
exp(1-a)
exp(-(1-a))
exp(1-a)
-log(exp(1-a))
len
(a*len+b*(1-a))^(1/c)
(a*len+b*(1-a))^(1/c)-len
x
(a*x+b*(1-a))^(1/c)
x
xbin
x=seq(5,200,by=2)
x
a*x+b*(1-a)
a*x+b*(1-a) -x
x-(a*x+b*(1-a))
plot(x,x-(a*x+b*(1-a)))
b
b*(1-a)
a
(1-a)
a
l2-l1
lam2-lam1
-log(a)
-log(a-1)
-log(a)
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
# This a simple R-script to test the Punt et al (1997) paper.#
#
#
# vonB growth parameters#
dt		<- 1/4#
da		<- seq(0, 30, dt)#
linf	<- 150#
k		<- 0.3#
#
len 	<- linf*(1-exp(-k*da))#
plot(da, len, type="o")#
#
#
# equivalent parameters for the generalized Schnute model.#
c	<- 1#
l1	<- 80#
l2	<- 100#
lam1	<- l1 + (linf-l1)*(1-exp(-k*dt))#
lam2	<- l2 + (linf-l2)*(1-exp(-k*dt))#
#
a	<- (l2^c-l1^c)/(lam2^c-lam1^c)#
b	<- (lam1^c*l2^c - l1^c*lam2^c) / (lam1^c-l1^c+l2^c-lam2^c)#
#
# Size intervals#
x	<- seq(0, linf/0.85, 5)
x
a*x+b*(1-a)
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
# This a simple R-script to test the Punt et al (1997) paper.#
#
#
# vonB growth parameters#
dt		<- 1/4#
da		<- seq(0, 30, dt)#
linf	<- 150#
k		<- 0.3#
#
len 	<- linf*(1-exp(-k*da))#
plot(da, len, type="o")#
#
#
# equivalent parameters for the generalized Schnute model.#
c	<- 1#
cv	<- 0.2#
l1	<- 80#
l2	<- 100#
lam1	<- l1 + (linf-l1)*(1-exp(-k*dt))#
lam2	<- l2 + (linf-l2)*(1-exp(-k*dt))#
#
a	<- (l2^c-l1^c)/(lam2^c-lam1^c)#
b	<- (lam1^c*l2^c - l1^c*lam2^c) / (lam1^c-l1^c+l2^c-lam2^c)#
#
# Size intervals#
x	<- seq(0, linf/0.85, 5)#
#
r	<- 1/cv^2
r
gamma <- a*x+b*(1-a) - x
gamma
plto(gamma)
plot(gamma)
gamma <- (a*x+b*(1-a)) - x
gamma
plot(gamma)
plot(1/gamma)
gamma <- (a*x+b*(1-a))
plot(gamma)
l2-lam2
(lam2-l1)
(lam2-l2)/(lam1-l1)
log((lam2-l2)/(lam1-l1))
log(1-(lam2-l2)/(lam1-l1))
exp(1-(lam2-l2)/(lam1-l1))
a
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
# This a simple R-script to test the Punt et al (1997) paper.#
#
#
# vonB growth parameters#
dt		<- 1/4#
da		<- seq(0, 30, dt)#
linf	<- 150#
k		<- 0.3#
#
len 	<- linf*(1-exp(-k*da))#
plot(da, len, type="o")#
#
#
# equivalent parameters for the generalized Schnute model.#
c	<- 1#
cv	<- 0.2#
l1	<- 80#
l2	<- 100#
lam1	<- l1 + (linf-l1)*(1-exp(-k*dt))#
lam2	<- l2 + (linf-l2)*(1-exp(-k*dt))#
#
a	<- (l2^c-l1^c)/(lam2^c-lam1^c)#
b	<- (lam1^c*l2^c - l1^c*lam2^c) / (lam1^c-l1^c+l2^c-lam2^c)#
#
# Size intervals#
x	<- seq(0, linf/0.85, 5)#
xa  <- xa[1:(length(x)-1)] + 0.5*diff(x)#
#
r	<- 1/cv^2
xa
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
# This a simple R-script to test the Punt et al (1997) paper.#
#
#
# vonB growth parameters#
dt		<- 1/4#
da		<- seq(0, 30, dt)#
linf	<- 150#
k		<- 0.3#
#
len 	<- linf*(1-exp(-k*da))#
plot(da, len, type="o")#
#
#
# equivalent parameters for the generalized Schnute model.#
c	<- 1#
cv	<- 0.2#
l1	<- 80#
l2	<- 100#
lam1	<- l1 + (linf-l1)*(1-exp(-k*dt))#
lam2	<- l2 + (linf-l2)*(1-exp(-k*dt))#
#
a	<- (l2^c-l1^c)/(lam2^c-lam1^c)#
b	<- (lam1^c*l2^c - l1^c*lam2^c) / (lam1^c-l1^c+l2^c-lam2^c)#
#
# Size intervals#
x	<- seq(0, linf/0.85, 5)#
xa  <- x[1:(length(x)-1)] + 0.5*diff(x)#
#
r	<- 1/cv^2
xa
x
a*xa+b*(1-a)
b
a
b*(1-a)
b
a = (lam2-lam1)/(l2-l1)
a
-log(a)
a
a*xa+b(1-a)
a*xa+b*(1-a)
(a*xa+b*(1-a))-xa
plot(xa,(a*xa+b*(1-a))-xa)
abline(h=0)
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
# This a simple R-script to test the Punt et al (1997) paper.#
#
#
# vonB growth parameters#
dt		<- 1/4#
da		<- seq(0, 30, dt)#
linf	<- 150#
k		<- 0.3#
#
len 	<- linf*(1-exp(-k*da))#
plot(da, len, type="o")#
#
#
# equivalent parameters for the generalized Schnute model.#
c	<- 1#
cv	<- 0.2#
l1	<- 80#
l2	<- 100#
lam1	<- l1 + (linf-l1)*(1-exp(-k*dt))#
lam2	<- l2 + (linf-l2)*(1-exp(-k*dt))#
#
a	<- (lam2^c-lam1^c)/(l2^c-l1^c)#
b	<- (lam1^c*l2^c - l1^c*lam2^c) / (lam1^c-l1^c+l2^c-lam2^c)#
#
# Size intervals#
x	<- seq(0, linf/0.85, 5)#
xa  <- x[1:(length(x)-1)] + 0.5*diff(x)#
#
r	<- 1/cv^2
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
# This a simple R-script to test the Punt et al (1997) paper.#
#
#
# vonB growth parameters#
dt		<- 1/4#
da		<- seq(0, 30, dt)#
linf	<- 150#
k		<- 0.3#
#
len 	<- linf*(1-exp(-k*da))#
plot(da, len, type="o")#
#
#
# equivalent parameters for the generalized Schnute model.#
c	<- 1#
cv	<- 0.2#
l1	<- 80#
l2	<- 100#
lam1	<- l1 + (linf-l1)*(1-exp(-k*dt))#
lam2	<- l2 + (linf-l2)*(1-exp(-k*dt))#
#
a	<- (lam2^c-lam1^c)/(l2^c-l1^c)#
b	<- (lam1^c*l2^c - l1^c*lam2^c) / (lam1^c-l1^c+l2^c-lam2^c)#
#
# Size intervals#
x	<- seq(0, linf/0.85, 5)#
xa  <- x[1:(length(x)-1)] + 0.5*diff(x)#
#
r	<- 1/cv^2#
si	<- (a*xa^c+b*(1-a))^(1/c)-xa
si
plot(si)
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
# This a simple R-script to test the Punt et al (1997) paper.#
#
#
# vonB growth parameters#
dt		<- 1/4#
da		<- seq(0, 30, dt)#
linf	<- 150#
k		<- 0.3#
#
len 	<- linf*(1-exp(-k*da))#
plot(da, len, type="o")#
#
#
# equivalent parameters for the generalized Schnute model.#
c	<- 1#
cv	<- 0.2#
l1	<- 80#
l2	<- 100#
lam1	<- l1 + (linf-l1)*(1-exp(-k*dt))#
lam2	<- l2 + (linf-l2)*(1-exp(-k*dt))#
#
a	<- (lam2^c-lam1^c)/(l2^c-l1^c)#
b	<- (lam1^c*l2^c - l1^c*lam2^c) / (lam1^c-l1^c+l2^c-lam2^c)#
#
# Size intervals#
x	<- seq(0, linf/0.85, 5)#
xa  <- x[1:(length(x)-1)] + 0.5*diff(x)#
#
r	<- 1/cv^2#
si	<- (a*xa^c+b*(1-a))^(1/c)-xa#
gamma	<- 1/(si*cv^2)
gamma
plot(gamma)
x-xa
x[1]-xa
xa[1]-x
length(x)
length(xa)
1/cv
cv
alpha = 1/cv^2
alpha
P=read.table(pipe("pbpaste"))
P=read.table(pipe("pbpaste"),header=F)
matplot(t(P),type="l")
matplot((P),type="l")
matplot(t(P),type="l")
P=read.table(pipe("pbpaste"),header=F)
matplot(t(P),type="l")
1/0.9^2
1/0.36^2
1/0.2^2
P=read.table(pipe("pbpaste"),header=F)
matplot(t(P),type="l")
?dbeta
?dgamma
p5=P
P=read.table(pipe("pbpaste"),header=F)
matplot(t(P),type="l")
N=read.table(pipe("pbpaste"),header=F)
matpot(t(tail(N)),type="l")
matplot(t(tail(N)),type="l")
N=read.table(pipe("pbpaste"),header=F)
matplot(t(tail(N)),type="l")
N=read.table(pipe("pbpaste"),header=F)
matplot(t(tail(N)),type="l")
N=read.table(pipe("pbpaste"),header=F)
matplot(t(tail(N)),type="l")
N=read.table(pipe("pbpaste"),header=F)
matplot(t(tail(N)),type="l")
N=read.table(pipe("pbpaste"),header=F)
matplot(t(tail(N)),type="l")
?plogis
sx=scan()
plot(sx)
plot(xbin[1]+diff(xbin),sx)
plot(xbin[1]+0.5*diff(xbin),sx)
xbin
diff(xbinb)
diff(xbin)
plot(xbin,sx)
plot(xbin[-1],sx)
?dgamma
a=1/0.2^2
a
s=xbin
xbin
s=10/a
s
plot(xbin,dgamma(xbin,a,s))
plot(xbin,dgamma(xbin,a,1/s))
1/s
a
10*a
a
a/10
a
s
p1=scan()
plot(p1)
xmin=xbin[1:(length(xbin)-1)]+0.5
xmid=xmin
xmid
plot(xmid,p1)
1/2.5
plot(xmid,p1)
p1=scan()
plot(xmid,p1)
lines(xmid,dgamma(xmid,a,1/s))
a=1/0.2^2
a
b=10/a
b
lines(xmid,dgamma(xmid,a,1/s))
sum(p1)
lines(xmid,dgamma(xmid,a,1/s))
N=read.table(pipe("pbpaste"),header=F)
matplot(t(N))
matplot(t(N),type="l")
matplot(t(tail(N)),type="l")
dim(N)
exp(5)
dim(N)
dim(N)
length(xbin)
C
dim(C)
head(C)
xbin
barplot(C[1,])
jj=scan()
C[1,]
lines(jj)
C[1,]-jj
M
M+R-C
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
## ___________________________________________________________ ###
## Simulation model for humpback chub                          ###
## Author: Steven Martell                                      ###
## DATE: September 26,  2011                                   ###
## Contact: martell.steve@gmail.com                            ###
##                                                             ###
## FUNCTIONS:                                                  ###
##   - .ibm => given N recruits returns list with the capture  ###
##             history of each recruit. It also fills the      ###
##             global variables C M and R for the assessment   ###
##             model.                                          ###
##   - .runIBM Loops over syr:nyr and applies the .ibm function###
##             to each of Rt recruits.                         ###
##                                                             ###
##                                                             ###
## ___________________________________________________________ ###
#
#
## __ Required libraries _____________________________________ ###
require( PBSmodelling )#
require( Hmisc )#
require( ggplot2 )#
#
#
## __ Simulation controls ____________________________________ ###
#
#  Model Dimensions#
syr     <- 1950     #initial year#
nyr     <- 2011     #final year#
dt      <- 3/12     #time step#
tmax    <- 50/dt    #max longevity index (50 yrs)#
dyr     <- seq(syr, nyr, by=dt)#
xbin    <- seq(3, 55, by=1)#
#
#  Growth (units in cm)#
lmin        <- 4#
lmin.sig    <- 0.4#
m.linf      <- 0.08#
linf        <- 40   #Asymptotic length (cm)#
k           <- 0.18 #Growth coefficient#
#
#  Selectivity#
lh          <- 10   #length @ 50% selectivity#
gamma       <- 1.5  #std in selectivity#
#
sample.yrs  <- seq(1989, 2011, by=dt)#
fishing     <- dyr %in% sample.yrs#
min.size    <- 15.0 #minimum size for tagging (15 cm)#
#
#
#
#  Parameter vector for the IBM model#
THETA <- list( lmin=lmin, #
               lmin.sig=lmin.sig, #
               m.linf=m.linf, #
               lh=lh, #
               gamma=gamma )#
#
set.seed(991)#
iclr <- rev(topo.colors(length(syr:nyr),0.5))#
Rt<-floor(rlnorm(length(syr:nyr), log(300), 0.9))#
Et<-runif(length(sample.yrs), 0.05, 0.2)  #Effort#
#
#  Global objects for storing data#
fish.id     <- 0    #Unique id for individual fish#
tag.id      <- 0    #Unique tag no. for individual#
#  Total catch, marked, recap, unmarked by year at length interval#
C   <- matrix(0,nrow=length(sample.yrs), ncol=length(xbin))#
M   <- matrix(0,nrow=length(sample.yrs), ncol=length(xbin))#
R   <- matrix(0,nrow=length(sample.yrs), ncol=length(xbin))#
#
## ___________________________________________________________ ###
#
#
#
#
#
## ___________________________________________________________ ###
## PROCEDURES                                                  ###
## ___________________________________________________________ ###
#
#
.ibm <- function( Nt, jyr, THETA )#
{#
    #ARGUMENTS:#
        #Nt    = Number of recruits from cohort#
        #jyr   = brood year (year the cohort was age-0)#
        #THETA = a list of simulation parameters for the ibm.#
    #
    #RETURNS:#
        #df    = a list w records of capture date, len,  tag.no#
#
    with(THETA, {#
        #jyr <- syr+(ii-1)#
        ## indexs i = individual; j=time#
#
        ## Calculate length & mortality for time j.#
        lj <- linf*(1.-exp(-k*dt*1:tmax))#
        mj <- m.linf*linf/lj#
        #
        ## Draw initial recruit size (gamma).#
        scale   <- (lmin.sig)^2/lmin#
        shape   <- lmin/scale#
        li <- rgamma(Nt, shape, 1/scale)#
        #
        #
        ## Growth trajectory#
        growth <- function ( li )#
        {#
            linf.i <- rnorm(1, linf, 0.1*linf)#
            li+(linf.i-li)*(1-exp(-k*1:tmax*dt))#
        }#
        L <- sapply(li, growth)#
        #
        ## Survival trajectory#
        ## S is a list of lengths of individuals at#
        ## the time they were alive.#
        survival <- function ( lj )#
        {#
            sj <- exp(-m.linf*linf/lj*dt)#
            pj <- rbinom(tmax, 1, sj)#
            nj <- which.min(pj)#
            return(lj[1:nj])#
        }#
        S <- apply(L, 2, survival)#
        #
#
        ## Capture history#
        pcap <- function ( lj )#
        {#
            #Arg: lj is the length at times j#
            #Algorithm:#
            #-1. determine index for sampling time periods (fyr)#
            #-2. determine capture probability at sampling times#
            #-3. if captured fish > 150 mm then assign a tag no.#
            if(!is.null(lj))#
            {#
                # 1. Index for sampling time periods (fyr)#
                n   <- length(lj)#
                d1  <- which(dyr==jyr)  #min index of dyr for jyr#
                d2  <- min(d1+n-1, length(dyr))#
                jj  <- d1:d2#
                iyr <- dyr[jj]          #years alive#
                fyr <- fishing[jj]      #years fished fyr==1#
                #
                #
                ## Did not survive into sampling years#
                if(length(iyr[fyr])==0) return(NULL)#
                #
                # -2. Selectivity at time of sampling#
                len <- (lj[1:length(jj)])[fyr]#
                iyr <- iyr[fyr]#
                # TODO Add annual effort to sj capture probability#
                eyr <- findInterval(iyr, sample.yrs)#
                #print(cbind(sample.yrs[eyr],Et[eyr]))#
                sj  <- Et[eyr]*plogis(len, lh, gamma)#
                #
                cj  <- rbinom(length(sj), 1, sj)#
                rid <- which(cj==1)  #row index for capture#
                if(length(rid)==0) return(NULL) #never captured#
                #
                tmp <- c(iyr[rid], len[rid],#
                    tag.no=rep(NA,length=length(rid)))#
                tmp <- matrix(tmp, ncol=3)#
                #
#
                # -3. Assign tag.id if greater than 150 mm#
                if(max(tmp[,2])>=min.size)#
                {#
                    tag.id <<- tag.id + 1#
                }#
                tmp[len[rid]>=min.size, 3] <- tag.id#
                #
                # -4. Populate global variables with catch history#
                tt <- findInterval(tmp[,1],sample.yrs)#
                xx <- findInterval(tmp[,2],xbin)#
                for(i in 1:length(tt))#
                    C[tt[i], xx[i]] <<- C[tt[i], xx[i]] + 1  #
#
                #print(cbind(tmp,sample.yrs[tt],xbin[xx],tmp[,3]))#
                #
                # - Newly marked fish into matrix M#
                im   <- !is.na(tmp[,3])#
                if(sum(im)>0) #fish was large enough to tag#
                {#
                    it <- min(which(im))#
                    iy <- findInterval(tmp[it,1],sample.yrs)#
                    ix <- findInterval(tmp[it,2],xbin)#
#
                    #print(cbind(tmp, sample.yrs[iy],xbin[ix]))#
                    M[iy, ix] <<- M[iy, ix] + 1#
                    #
                    ir <- which(im)[-1]#
                    ry <- findInterval(tmp[ir,1],sample.yrs)#
                    rx <- findInterval(tmp[ir,2],xbin)#
                    for(i in 1:length(ry))#
                        R[ry[i], rx[i]] <<- R[ry[i], rx[i]] + 1#
                }#
                #
                return(tmp)#
            }#
        }#
        P <- sapply(S, pcap)#
        return(P)#
    })#
}#
#
.runIBM <- function()#
{#
    j <- 1#
    A <- NULL#
    for(i in syr:nyr)#
    {#
        A <- c(A, .ibm(Rt[j], i, THETA))#
        j <- j+1#
    }#
    return(A)#
}#
#
.writeLSMRdata <- function()#
{#
	# This function writes the data file for LSMR model#
	fn <- "simLSMR.dat"#
	C  <- cbind(floor(sample.yrs),sample.yrs%%1*4+1,C)#
	M  <- cbind(floor(sample.yrs),sample.yrs%%1*4+1,M)#
	R  <- cbind(floor(sample.yrs),sample.yrs%%1*4+1,R)#
	#
	write("#Simulated data from HBCsim.R", fn)#
	write("#Model Dimensions", fn, append=T)#
	write("#Years, timestep", fn, append=T)#
	write(c(range(sample.yrs), dt), fn, append=T)#
	write("#Array dimensions(C, M, R)", fn, append=T)#
	write(dim(C), fn, append=T)#
	write("#Number of length intervals", fn, append=T)#
	nbin=length(xbin)+1#
	write(nbin, fn, append=T)#
	write("#Length intervals (cm)", fn, append=T)#
	write(c(xbin,xbin[nbin]+diff(xbin[(nbin-1):nbin]), fn, append=T)#
	#
	write("#Catch at length by period", fn, append=T)#
	write("#Year, Period, Count ...", fn, append=T)#
	write.table(C, fn, append=T, col.names=F, row.names=F)#
	write("#Number Marked at length by period", fn, append=T)#
	write("#Year, Period, Count ...", fn, append=T)#
	write.table(M, fn, append=T, col.names=F, row.names=F)#
	write("#Number Recaptured at length by period", fn, append=T)#
	write("#Year, Period, Count ...", fn, append=T)#
	write.table(R, fn, append=T, col.names=F, row.names=F)#
	#
	write("#End of file", fn, append=T)#
	write(999, fn, append=T)#
	#
}#
#
## ___________________________________________________________ ###
## MAIN                                                        ###
## ___________________________________________________________ ###
#A  <- .ibm(1000, 1980, THETA)#
A <- .runIBM()#
.writeLSMRdata()#
#
## ___________________________________________________________ ###
#
par(mfcol=c(6, 4), las=1, mar=c(2, 2, 1, 1), oma=c(3, 3, 1, 1))#
for(i in seq(1,length(sample.yrs)-1/dt,by=1/dt))#
{#
	#
	ut <- colSums(C[i:(i+3),]-M[i:(i+3),]-R[i:(i+3),])#
	mt <- colSums(M[i:(i+3),])#
	rt <- colSums(R[i:(i+3),])#
	tmp <- rbind(ut, mt, rt)#
	#
    barplot(tmp,names.arg=xbin,xlab=""#
    ,ylab="", main=sample.yrs[i])#
}#
mtext(c("Length (cm)","Frequency"), #
    c(1, 2), outer=T, las=0, line=1)
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
## ___________________________________________________________ ###
## Simulation model for humpback chub                          ###
## Author: Steven Martell                                      ###
## DATE: September 26,  2011                                   ###
## Contact: martell.steve@gmail.com                            ###
##                                                             ###
## FUNCTIONS:                                                  ###
##   - .ibm => given N recruits returns list with the capture  ###
##             history of each recruit. It also fills the      ###
##             global variables C M and R for the assessment   ###
##             model.                                          ###
##   - .runIBM Loops over syr:nyr and applies the .ibm function###
##             to each of Rt recruits.                         ###
##                                                             ###
##                                                             ###
## ___________________________________________________________ ###
#
#
## __ Required libraries _____________________________________ ###
require( PBSmodelling )#
require( Hmisc )#
require( ggplot2 )#
#
#
## __ Simulation controls ____________________________________ ###
#
#  Model Dimensions#
syr     <- 1950     #initial year#
nyr     <- 2011     #final year#
dt      <- 3/12     #time step#
tmax    <- 50/dt    #max longevity index (50 yrs)#
dyr     <- seq(syr, nyr, by=dt)#
xbin    <- seq(3, 55, by=1)#
#
#  Growth (units in cm)#
lmin        <- 4#
lmin.sig    <- 0.4#
m.linf      <- 0.08#
linf        <- 40   #Asymptotic length (cm)#
k           <- 0.18 #Growth coefficient#
#
#  Selectivity#
lh          <- 10   #length @ 50% selectivity#
gamma       <- 1.5  #std in selectivity#
#
sample.yrs  <- seq(1989, 2011, by=dt)#
fishing     <- dyr %in% sample.yrs#
min.size    <- 15.0 #minimum size for tagging (15 cm)#
#
#
#
#  Parameter vector for the IBM model#
THETA <- list( lmin=lmin, #
               lmin.sig=lmin.sig, #
               m.linf=m.linf, #
               lh=lh, #
               gamma=gamma )#
#
set.seed(991)#
iclr <- rev(topo.colors(length(syr:nyr),0.5))#
Rt<-floor(rlnorm(length(syr:nyr), log(300), 0.9))#
Et<-runif(length(sample.yrs), 0.05, 0.2)  #Effort#
#
#  Global objects for storing data#
fish.id     <- 0    #Unique id for individual fish#
tag.id      <- 0    #Unique tag no. for individual#
#  Total catch, marked, recap, unmarked by year at length interval#
C   <- matrix(0,nrow=length(sample.yrs), ncol=length(xbin))#
M   <- matrix(0,nrow=length(sample.yrs), ncol=length(xbin))#
R   <- matrix(0,nrow=length(sample.yrs), ncol=length(xbin))#
#
## ___________________________________________________________ ###
#
#
#
#
#
## ___________________________________________________________ ###
## PROCEDURES                                                  ###
## ___________________________________________________________ ###
#
#
.ibm <- function( Nt, jyr, THETA )#
{#
    #ARGUMENTS:#
        #Nt    = Number of recruits from cohort#
        #jyr   = brood year (year the cohort was age-0)#
        #THETA = a list of simulation parameters for the ibm.#
    #
    #RETURNS:#
        #df    = a list w records of capture date, len,  tag.no#
#
    with(THETA, {#
        #jyr <- syr+(ii-1)#
        ## indexs i = individual; j=time#
#
        ## Calculate length & mortality for time j.#
        lj <- linf*(1.-exp(-k*dt*1:tmax))#
        mj <- m.linf*linf/lj#
        #
        ## Draw initial recruit size (gamma).#
        scale   <- (lmin.sig)^2/lmin#
        shape   <- lmin/scale#
        li <- rgamma(Nt, shape, 1/scale)#
        #
        #
        ## Growth trajectory#
        growth <- function ( li )#
        {#
            linf.i <- rnorm(1, linf, 0.1*linf)#
            li+(linf.i-li)*(1-exp(-k*1:tmax*dt))#
        }#
        L <- sapply(li, growth)#
        #
        ## Survival trajectory#
        ## S is a list of lengths of individuals at#
        ## the time they were alive.#
        survival <- function ( lj )#
        {#
            sj <- exp(-m.linf*linf/lj*dt)#
            pj <- rbinom(tmax, 1, sj)#
            nj <- which.min(pj)#
            return(lj[1:nj])#
        }#
        S <- apply(L, 2, survival)#
        #
#
        ## Capture history#
        pcap <- function ( lj )#
        {#
            #Arg: lj is the length at times j#
            #Algorithm:#
            #-1. determine index for sampling time periods (fyr)#
            #-2. determine capture probability at sampling times#
            #-3. if captured fish > 150 mm then assign a tag no.#
            if(!is.null(lj))#
            {#
                # 1. Index for sampling time periods (fyr)#
                n   <- length(lj)#
                d1  <- which(dyr==jyr)  #min index of dyr for jyr#
                d2  <- min(d1+n-1, length(dyr))#
                jj  <- d1:d2#
                iyr <- dyr[jj]          #years alive#
                fyr <- fishing[jj]      #years fished fyr==1#
                #
                #
                ## Did not survive into sampling years#
                if(length(iyr[fyr])==0) return(NULL)#
                #
                # -2. Selectivity at time of sampling#
                len <- (lj[1:length(jj)])[fyr]#
                iyr <- iyr[fyr]#
                # TODO Add annual effort to sj capture probability#
                eyr <- findInterval(iyr, sample.yrs)#
                #print(cbind(sample.yrs[eyr],Et[eyr]))#
                sj  <- Et[eyr]*plogis(len, lh, gamma)#
                #
                cj  <- rbinom(length(sj), 1, sj)#
                rid <- which(cj==1)  #row index for capture#
                if(length(rid)==0) return(NULL) #never captured#
                #
                tmp <- c(iyr[rid], len[rid],#
                    tag.no=rep(NA,length=length(rid)))#
                tmp <- matrix(tmp, ncol=3)#
                #
#
                # -3. Assign tag.id if greater than 150 mm#
                if(max(tmp[,2])>=min.size)#
                {#
                    tag.id <<- tag.id + 1#
                }#
                tmp[len[rid]>=min.size, 3] <- tag.id#
                #
                # -4. Populate global variables with catch history#
                tt <- findInterval(tmp[,1],sample.yrs)#
                xx <- findInterval(tmp[,2],xbin)#
                for(i in 1:length(tt))#
                    C[tt[i], xx[i]] <<- C[tt[i], xx[i]] + 1  #
#
                #print(cbind(tmp,sample.yrs[tt],xbin[xx],tmp[,3]))#
                #
                # - Newly marked fish into matrix M#
                im   <- !is.na(tmp[,3])#
                if(sum(im)>0) #fish was large enough to tag#
                {#
                    it <- min(which(im))#
                    iy <- findInterval(tmp[it,1],sample.yrs)#
                    ix <- findInterval(tmp[it,2],xbin)#
#
                    #print(cbind(tmp, sample.yrs[iy],xbin[ix]))#
                    M[iy, ix] <<- M[iy, ix] + 1#
                    #
                    ir <- which(im)[-1]#
                    ry <- findInterval(tmp[ir,1],sample.yrs)#
                    rx <- findInterval(tmp[ir,2],xbin)#
                    for(i in 1:length(ry))#
                        R[ry[i], rx[i]] <<- R[ry[i], rx[i]] + 1#
                }#
                #
                return(tmp)#
            }#
        }#
        P <- sapply(S, pcap)#
        return(P)#
    })#
}#
#
.runIBM <- function()#
{#
    j <- 1#
    A <- NULL#
    for(i in syr:nyr)#
    {#
        A <- c(A, .ibm(Rt[j], i, THETA))#
        j <- j+1#
    }#
    return(A)#
}#
#
.writeLSMRdata <- function()#
{#
	# This function writes the data file for LSMR model#
	fn <- "simLSMR.dat"#
	C  <- cbind(floor(sample.yrs),sample.yrs%%1*4+1,C)#
	M  <- cbind(floor(sample.yrs),sample.yrs%%1*4+1,M)#
	R  <- cbind(floor(sample.yrs),sample.yrs%%1*4+1,R)#
	#
	write("#Simulated data from HBCsim.R", fn)#
	write("#Model Dimensions", fn, append=T)#
	write("#Years, timestep", fn, append=T)#
	write(c(range(sample.yrs), dt), fn, append=T)#
	write("#Array dimensions(C, M, R)", fn, append=T)#
	write(dim(C), fn, append=T)#
	write("#Number of length intervals", fn, append=T)#
	nbin=length(xbin)+1#
	write(nbin, fn, append=T)#
	write("#Length intervals (cm)", fn, append=T)#
	write(c(xbin,xbin[nbin]+diff(xbin[(nbin-1):nbin])), fn, append=T)#
	#
	write("#Catch at length by period", fn, append=T)#
	write("#Year, Period, Count ...", fn, append=T)#
	write.table(C, fn, append=T, col.names=F, row.names=F)#
	write("#Number Marked at length by period", fn, append=T)#
	write("#Year, Period, Count ...", fn, append=T)#
	write.table(M, fn, append=T, col.names=F, row.names=F)#
	write("#Number Recaptured at length by period", fn, append=T)#
	write("#Year, Period, Count ...", fn, append=T)#
	write.table(R, fn, append=T, col.names=F, row.names=F)#
	#
	write("#End of file", fn, append=T)#
	write(999, fn, append=T)#
	#
}#
#
## ___________________________________________________________ ###
## MAIN                                                        ###
## ___________________________________________________________ ###
#A  <- .ibm(1000, 1980, THETA)#
A <- .runIBM()#
.writeLSMRdata()#
#
## ___________________________________________________________ ###
#
par(mfcol=c(6, 4), las=1, mar=c(2, 2, 1, 1), oma=c(3, 3, 1, 1))#
for(i in seq(1,length(sample.yrs)-1/dt,by=1/dt))#
{#
	#
	ut <- colSums(C[i:(i+3),]-M[i:(i+3),]-R[i:(i+3),])#
	mt <- colSums(M[i:(i+3),])#
	rt <- colSums(R[i:(i+3),])#
	tmp <- rbind(ut, mt, rt)#
	#
    barplot(tmp,names.arg=xbin,xlab=""#
    ,ylab="", main=sample.yrs[i])#
}#
mtext(c("Length (cm)","Frequency"), #
    c(1, 2), outer=T, las=0, line=1)
xbin[55]
xbin[54]
xbin[53]
xbin[52]
diff(xbin[52:53])
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
## ___________________________________________________________ ###
## Simulation model for humpback chub                          ###
## Author: Steven Martell                                      ###
## DATE: September 26,  2011                                   ###
## Contact: martell.steve@gmail.com                            ###
##                                                             ###
## FUNCTIONS:                                                  ###
##   - .ibm => given N recruits returns list with the capture  ###
##             history of each recruit. It also fills the      ###
##             global variables C M and R for the assessment   ###
##             model.                                          ###
##   - .runIBM Loops over syr:nyr and applies the .ibm function###
##             to each of Rt recruits.                         ###
##                                                             ###
##                                                             ###
## ___________________________________________________________ ###
#
#
## __ Required libraries _____________________________________ ###
require( PBSmodelling )#
require( Hmisc )#
require( ggplot2 )#
#
#
## __ Simulation controls ____________________________________ ###
#
#  Model Dimensions#
syr     <- 1950     #initial year#
nyr     <- 2011     #final year#
dt      <- 3/12     #time step#
tmax    <- 50/dt    #max longevity index (50 yrs)#
dyr     <- seq(syr, nyr, by=dt)#
xbin    <- seq(3, 55, by=1)#
#
#  Growth (units in cm)#
lmin        <- 4#
lmin.sig    <- 0.4#
m.linf      <- 0.08#
linf        <- 40   #Asymptotic length (cm)#
k           <- 0.18 #Growth coefficient#
#
#  Selectivity#
lh          <- 10   #length @ 50% selectivity#
gamma       <- 1.5  #std in selectivity#
#
sample.yrs  <- seq(1989, 2011, by=dt)#
fishing     <- dyr %in% sample.yrs#
min.size    <- 15.0 #minimum size for tagging (15 cm)#
#
#
#
#  Parameter vector for the IBM model#
THETA <- list( lmin=lmin, #
               lmin.sig=lmin.sig, #
               m.linf=m.linf, #
               lh=lh, #
               gamma=gamma )#
#
set.seed(991)#
iclr <- rev(topo.colors(length(syr:nyr),0.5))#
Rt<-floor(rlnorm(length(syr:nyr), log(300), 0.9))#
Et<-runif(length(sample.yrs), 0.05, 0.2)  #Effort#
#
#  Global objects for storing data#
fish.id     <- 0    #Unique id for individual fish#
tag.id      <- 0    #Unique tag no. for individual#
#  Total catch, marked, recap, unmarked by year at length interval#
C   <- matrix(0,nrow=length(sample.yrs), ncol=length(xbin))#
M   <- matrix(0,nrow=length(sample.yrs), ncol=length(xbin))#
R   <- matrix(0,nrow=length(sample.yrs), ncol=length(xbin))#
#
## ___________________________________________________________ ###
#
#
#
#
#
## ___________________________________________________________ ###
## PROCEDURES                                                  ###
## ___________________________________________________________ ###
#
#
.ibm <- function( Nt, jyr, THETA )#
{#
    #ARGUMENTS:#
        #Nt    = Number of recruits from cohort#
        #jyr   = brood year (year the cohort was age-0)#
        #THETA = a list of simulation parameters for the ibm.#
    #
    #RETURNS:#
        #df    = a list w records of capture date, len,  tag.no#
#
    with(THETA, {#
        #jyr <- syr+(ii-1)#
        ## indexs i = individual; j=time#
#
        ## Calculate length & mortality for time j.#
        lj <- linf*(1.-exp(-k*dt*1:tmax))#
        mj <- m.linf*linf/lj#
        #
        ## Draw initial recruit size (gamma).#
        scale   <- (lmin.sig)^2/lmin#
        shape   <- lmin/scale#
        li <- rgamma(Nt, shape, 1/scale)#
        #
        #
        ## Growth trajectory#
        growth <- function ( li )#
        {#
            linf.i <- rnorm(1, linf, 0.1*linf)#
            li+(linf.i-li)*(1-exp(-k*1:tmax*dt))#
        }#
        L <- sapply(li, growth)#
        #
        ## Survival trajectory#
        ## S is a list of lengths of individuals at#
        ## the time they were alive.#
        survival <- function ( lj )#
        {#
            sj <- exp(-m.linf*linf/lj*dt)#
            pj <- rbinom(tmax, 1, sj)#
            nj <- which.min(pj)#
            return(lj[1:nj])#
        }#
        S <- apply(L, 2, survival)#
        #
#
        ## Capture history#
        pcap <- function ( lj )#
        {#
            #Arg: lj is the length at times j#
            #Algorithm:#
            #-1. determine index for sampling time periods (fyr)#
            #-2. determine capture probability at sampling times#
            #-3. if captured fish > 150 mm then assign a tag no.#
            if(!is.null(lj))#
            {#
                # 1. Index for sampling time periods (fyr)#
                n   <- length(lj)#
                d1  <- which(dyr==jyr)  #min index of dyr for jyr#
                d2  <- min(d1+n-1, length(dyr))#
                jj  <- d1:d2#
                iyr <- dyr[jj]          #years alive#
                fyr <- fishing[jj]      #years fished fyr==1#
                #
                #
                ## Did not survive into sampling years#
                if(length(iyr[fyr])==0) return(NULL)#
                #
                # -2. Selectivity at time of sampling#
                len <- (lj[1:length(jj)])[fyr]#
                iyr <- iyr[fyr]#
                # TODO Add annual effort to sj capture probability#
                eyr <- findInterval(iyr, sample.yrs)#
                #print(cbind(sample.yrs[eyr],Et[eyr]))#
                sj  <- Et[eyr]*plogis(len, lh, gamma)#
                #
                cj  <- rbinom(length(sj), 1, sj)#
                rid <- which(cj==1)  #row index for capture#
                if(length(rid)==0) return(NULL) #never captured#
                #
                tmp <- c(iyr[rid], len[rid],#
                    tag.no=rep(NA,length=length(rid)))#
                tmp <- matrix(tmp, ncol=3)#
                #
#
                # -3. Assign tag.id if greater than 150 mm#
                if(max(tmp[,2])>=min.size)#
                {#
                    tag.id <<- tag.id + 1#
                }#
                tmp[len[rid]>=min.size, 3] <- tag.id#
                #
                # -4. Populate global variables with catch history#
                tt <- findInterval(tmp[,1],sample.yrs)#
                xx <- findInterval(tmp[,2],xbin)#
                for(i in 1:length(tt))#
                    C[tt[i], xx[i]] <<- C[tt[i], xx[i]] + 1  #
#
                #print(cbind(tmp,sample.yrs[tt],xbin[xx],tmp[,3]))#
                #
                # - Newly marked fish into matrix M#
                im   <- !is.na(tmp[,3])#
                if(sum(im)>0) #fish was large enough to tag#
                {#
                    it <- min(which(im))#
                    iy <- findInterval(tmp[it,1],sample.yrs)#
                    ix <- findInterval(tmp[it,2],xbin)#
#
                    #print(cbind(tmp, sample.yrs[iy],xbin[ix]))#
                    M[iy, ix] <<- M[iy, ix] + 1#
                    #
                    ir <- which(im)[-1]#
                    ry <- findInterval(tmp[ir,1],sample.yrs)#
                    rx <- findInterval(tmp[ir,2],xbin)#
                    for(i in 1:length(ry))#
                        R[ry[i], rx[i]] <<- R[ry[i], rx[i]] + 1#
                }#
                #
                return(tmp)#
            }#
        }#
        P <- sapply(S, pcap)#
        return(P)#
    })#
}#
#
.runIBM <- function()#
{#
    j <- 1#
    A <- NULL#
    for(i in syr:nyr)#
    {#
        A <- c(A, .ibm(Rt[j], i, THETA))#
        j <- j+1#
    }#
    return(A)#
}#
#
.writeLSMRdata <- function()#
{#
	# This function writes the data file for LSMR model#
	fn <- "simLSMR.dat"#
	C  <- cbind(floor(sample.yrs),sample.yrs%%1*4+1,C)#
	M  <- cbind(floor(sample.yrs),sample.yrs%%1*4+1,M)#
	R  <- cbind(floor(sample.yrs),sample.yrs%%1*4+1,R)#
	#
	write("#Simulated data from HBCsim.R", fn)#
	write("#Model Dimensions", fn, append=T)#
	write("#Years, timestep", fn, append=T)#
	write(c(range(sample.yrs), dt), fn, append=T)#
	write("#Array dimensions(C, M, R)", fn, append=T)#
	write(dim(C), fn, append=T)#
	write("#Number of length intervals", fn, append=T)#
	nbin=length(xbin)+1#
	write(nbin, fn, append=T)#
	write("#Length intervals (cm)", fn, append=T)#
	write(c(xbin,xbin[nbin]+diff(xbin[(nbin-2):(nbin-1)])), fn, append=T)#
	#
	write("#Catch at length by period", fn, append=T)#
	write("#Year, Period, Count ...", fn, append=T)#
	write.table(C, fn, append=T, col.names=F, row.names=F)#
	write("#Number Marked at length by period", fn, append=T)#
	write("#Year, Period, Count ...", fn, append=T)#
	write.table(M, fn, append=T, col.names=F, row.names=F)#
	write("#Number Recaptured at length by period", fn, append=T)#
	write("#Year, Period, Count ...", fn, append=T)#
	write.table(R, fn, append=T, col.names=F, row.names=F)#
	#
	write("#End of file", fn, append=T)#
	write(999, fn, append=T)#
	#
}#
#
## ___________________________________________________________ ###
## MAIN                                                        ###
## ___________________________________________________________ ###
#A  <- .ibm(1000, 1980, THETA)#
A <- .runIBM()#
.writeLSMRdata()#
#
## ___________________________________________________________ ###
#
par(mfcol=c(6, 4), las=1, mar=c(2, 2, 1, 1), oma=c(3, 3, 1, 1))#
for(i in seq(1,length(sample.yrs)-1/dt,by=1/dt))#
{#
	#
	ut <- colSums(C[i:(i+3),]-M[i:(i+3),]-R[i:(i+3),])#
	mt <- colSums(M[i:(i+3),])#
	rt <- colSums(R[i:(i+3),])#
	tmp <- rbind(ut, mt, rt)#
	#
    barplot(tmp,names.arg=xbin,xlab=""#
    ,ylab="", main=sample.yrs[i])#
}#
mtext(c("Length (cm)","Frequency"), #
    c(1, 2), outer=T, las=0, line=1)
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
## ___________________________________________________________ ###
## Simulation model for humpback chub                          ###
## Author: Steven Martell                                      ###
## DATE: September 26,  2011                                   ###
## Contact: martell.steve@gmail.com                            ###
##                                                             ###
## FUNCTIONS:                                                  ###
##   - .ibm => given N recruits returns list with the capture  ###
##             history of each recruit. It also fills the      ###
##             global variables C M and R for the assessment   ###
##             model.                                          ###
##   - .runIBM Loops over syr:nyr and applies the .ibm function###
##             to each of Rt recruits.                         ###
##                                                             ###
##                                                             ###
## ___________________________________________________________ ###
#
#
## __ Required libraries _____________________________________ ###
require( PBSmodelling )#
require( Hmisc )#
require( ggplot2 )#
#
#
## __ Simulation controls ____________________________________ ###
#
#  Model Dimensions#
syr     <- 1950     #initial year#
nyr     <- 2011     #final year#
dt      <- 3/12     #time step#
tmax    <- 50/dt    #max longevity index (50 yrs)#
dyr     <- seq(syr, nyr, by=dt)#
xbin    <- seq(3, 55, by=1)#
#
#  Growth (units in cm)#
lmin        <- 4#
lmin.sig    <- 0.4#
m.linf      <- 0.08#
linf        <- 40   #Asymptotic length (cm)#
k           <- 0.18 #Growth coefficient#
#
#  Selectivity#
lh          <- 10   #length @ 50% selectivity#
gamma       <- 1.5  #std in selectivity#
#
sample.yrs  <- seq(1989, 2011, by=dt)#
fishing     <- dyr %in% sample.yrs#
min.size    <- 15.0 #minimum size for tagging (15 cm)#
#
#
#
#  Parameter vector for the IBM model#
THETA <- list( lmin=lmin, #
               lmin.sig=lmin.sig, #
               m.linf=m.linf, #
               lh=lh, #
               gamma=gamma )#
#
set.seed(991)#
iclr <- rev(topo.colors(length(syr:nyr),0.5))#
Rt<-floor(rlnorm(length(syr:nyr), log(300), 0.9))#
Et<-runif(length(sample.yrs), 0.05, 0.2)  #Effort#
#
#  Global objects for storing data#
fish.id     <- 0    #Unique id for individual fish#
tag.id      <- 0    #Unique tag no. for individual#
#  Total catch, marked, recap, unmarked by year at length interval#
C   <- matrix(0,nrow=length(sample.yrs), ncol=length(xbin))#
M   <- matrix(0,nrow=length(sample.yrs), ncol=length(xbin))#
R   <- matrix(0,nrow=length(sample.yrs), ncol=length(xbin))#
#
## ___________________________________________________________ ###
#
#
#
#
#
## ___________________________________________________________ ###
## PROCEDURES                                                  ###
## ___________________________________________________________ ###
#
#
.ibm <- function( Nt, jyr, THETA )#
{#
    #ARGUMENTS:#
        #Nt    = Number of recruits from cohort#
        #jyr   = brood year (year the cohort was age-0)#
        #THETA = a list of simulation parameters for the ibm.#
    #
    #RETURNS:#
        #df    = a list w records of capture date, len,  tag.no#
#
    with(THETA, {#
        #jyr <- syr+(ii-1)#
        ## indexs i = individual; j=time#
#
        ## Calculate length & mortality for time j.#
        lj <- linf*(1.-exp(-k*dt*1:tmax))#
        mj <- m.linf*linf/lj#
        #
        ## Draw initial recruit size (gamma).#
        scale   <- (lmin.sig)^2/lmin#
        shape   <- lmin/scale#
        li <- rgamma(Nt, shape, 1/scale)#
        #
        #
        ## Growth trajectory#
        growth <- function ( li )#
        {#
            linf.i <- rnorm(1, linf, 0.1*linf)#
            li+(linf.i-li)*(1-exp(-k*1:tmax*dt))#
        }#
        L <- sapply(li, growth)#
        #
        ## Survival trajectory#
        ## S is a list of lengths of individuals at#
        ## the time they were alive.#
        survival <- function ( lj )#
        {#
            sj <- exp(-m.linf*linf/lj*dt)#
            pj <- rbinom(tmax, 1, sj)#
            nj <- which.min(pj)#
            return(lj[1:nj])#
        }#
        S <- apply(L, 2, survival)#
        #
#
        ## Capture history#
        pcap <- function ( lj )#
        {#
            #Arg: lj is the length at times j#
            #Algorithm:#
            #-1. determine index for sampling time periods (fyr)#
            #-2. determine capture probability at sampling times#
            #-3. if captured fish > 150 mm then assign a tag no.#
            if(!is.null(lj))#
            {#
                # 1. Index for sampling time periods (fyr)#
                n   <- length(lj)#
                d1  <- which(dyr==jyr)  #min index of dyr for jyr#
                d2  <- min(d1+n-1, length(dyr))#
                jj  <- d1:d2#
                iyr <- dyr[jj]          #years alive#
                fyr <- fishing[jj]      #years fished fyr==1#
                #
                #
                ## Did not survive into sampling years#
                if(length(iyr[fyr])==0) return(NULL)#
                #
                # -2. Selectivity at time of sampling#
                len <- (lj[1:length(jj)])[fyr]#
                iyr <- iyr[fyr]#
                # TODO Add annual effort to sj capture probability#
                eyr <- findInterval(iyr, sample.yrs)#
                #print(cbind(sample.yrs[eyr],Et[eyr]))#
                sj  <- Et[eyr]*plogis(len, lh, gamma)#
                #
                cj  <- rbinom(length(sj), 1, sj)#
                rid <- which(cj==1)  #row index for capture#
                if(length(rid)==0) return(NULL) #never captured#
                #
                tmp <- c(iyr[rid], len[rid],#
                    tag.no=rep(NA,length=length(rid)))#
                tmp <- matrix(tmp, ncol=3)#
                #
#
                # -3. Assign tag.id if greater than 150 mm#
                if(max(tmp[,2])>=min.size)#
                {#
                    tag.id <<- tag.id + 1#
                }#
                tmp[len[rid]>=min.size, 3] <- tag.id#
                #
                # -4. Populate global variables with catch history#
                tt <- findInterval(tmp[,1],sample.yrs)#
                xx <- findInterval(tmp[,2],xbin)#
                for(i in 1:length(tt))#
                    C[tt[i], xx[i]] <<- C[tt[i], xx[i]] + 1  #
#
                #print(cbind(tmp,sample.yrs[tt],xbin[xx],tmp[,3]))#
                #
                # - Newly marked fish into matrix M#
                im   <- !is.na(tmp[,3])#
                if(sum(im)>0) #fish was large enough to tag#
                {#
                    it <- min(which(im))#
                    iy <- findInterval(tmp[it,1],sample.yrs)#
                    ix <- findInterval(tmp[it,2],xbin)#
#
                    #print(cbind(tmp, sample.yrs[iy],xbin[ix]))#
                    M[iy, ix] <<- M[iy, ix] + 1#
                    #
                    ir <- which(im)[-1]#
                    ry <- findInterval(tmp[ir,1],sample.yrs)#
                    rx <- findInterval(tmp[ir,2],xbin)#
                    for(i in 1:length(ry))#
                        R[ry[i], rx[i]] <<- R[ry[i], rx[i]] + 1#
                }#
                #
                return(tmp)#
            }#
        }#
        P <- sapply(S, pcap)#
        return(P)#
    })#
}#
#
.runIBM <- function()#
{#
    j <- 1#
    A <- NULL#
    for(i in syr:nyr)#
    {#
        A <- c(A, .ibm(Rt[j], i, THETA))#
        j <- j+1#
    }#
    return(A)#
}#
#
.writeLSMRdata <- function()#
{#
	# This function writes the data file for LSMR model#
	fn <- "simLSMR.dat"#
	C  <- cbind(floor(sample.yrs),sample.yrs%%1*4+1,C)#
	M  <- cbind(floor(sample.yrs),sample.yrs%%1*4+1,M)#
	R  <- cbind(floor(sample.yrs),sample.yrs%%1*4+1,R)#
	#
	write("#Simulated data from HBCsim.R", fn)#
	write("#Model Dimensions", fn, append=T)#
	write("#Years, timestep", fn, append=T)#
	write(c(range(sample.yrs), dt), fn, append=T)#
	write("#Array dimensions(C, M, R)", fn, append=T)#
	write(dim(C), fn, append=T)#
	write("#Number of length intervals", fn, append=T)#
	nbin=length(xbin)+1#
	write(nbin, fn, append=T)#
	write("#Length intervals (cm)", fn, append=T)#
	write(c(xbin,xbin[nbin-1]+diff(xbin[(nbin-2):(nbin-1)])), fn, append=T)#
	#
	write("#Catch at length by period", fn, append=T)#
	write("#Year, Period, Count ...", fn, append=T)#
	write.table(C, fn, append=T, col.names=F, row.names=F)#
	write("#Number Marked at length by period", fn, append=T)#
	write("#Year, Period, Count ...", fn, append=T)#
	write.table(M, fn, append=T, col.names=F, row.names=F)#
	write("#Number Recaptured at length by period", fn, append=T)#
	write("#Year, Period, Count ...", fn, append=T)#
	write.table(R, fn, append=T, col.names=F, row.names=F)#
	#
	write("#End of file", fn, append=T)#
	write(999, fn, append=T)#
	#
}#
#
## ___________________________________________________________ ###
## MAIN                                                        ###
## ___________________________________________________________ ###
#A  <- .ibm(1000, 1980, THETA)#
A <- .runIBM()#
.writeLSMRdata()#
#
## ___________________________________________________________ ###
#
par(mfcol=c(6, 4), las=1, mar=c(2, 2, 1, 1), oma=c(3, 3, 1, 1))#
for(i in seq(1,length(sample.yrs)-1/dt,by=1/dt))#
{#
	#
	ut <- colSums(C[i:(i+3),]-M[i:(i+3),]-R[i:(i+3),])#
	mt <- colSums(M[i:(i+3),])#
	rt <- colSums(R[i:(i+3),])#
	tmp <- rbind(ut, mt, rt)#
	#
    barplot(tmp,names.arg=xbin,xlab=""#
    ,ylab="", main=sample.yrs[i])#
}#
mtext(c("Length (cm)","Frequency"), #
    c(1, 2), outer=T, las=0, line=1)
C
Chat=read.table(pipe("pbpaste"),header=F)
plot(C[1,])
lines(Chat[1,])
Chat[1,]
plot(C[1,])
lines(Chat[1,])
Chat=as.matrix(read.table(pipe("pbpaste"),header=F))
lines(Chat[1,])
plot(C[80,])
lines(Chat[80,])
plot(C[40,])
lines(Chat[40,])
lines(Chat[60,])
plot(C[60,])
lines(Chat[60,])
?dpois
Chat=as.matrix(read.table(pipe("pbpaste"),header=F))
plot(C[60,])
lines(Chat[60,])
plot(C[80,])
lines(Chat[80,])
plot(C[8,])
lines(Chat[8,])
N=as.matrix(read.table(pipe("pbpaste"),header=F))
matplot(t(N),type="l")
matplot(t(tail(N)),type="l")
