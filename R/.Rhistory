}
## Solver routine to estimate parameters.
solver<-function(theta,objfun,hess=FALSE)
{
fit<-optim(theta,objfun,method="BFGS",hessian=hess)
if(hess==TRUE)
{
H=fit$hessian     #Matrix of 2nd derivatives
V=solve(H)        #Variance covariance matrix
std=sqrt(diag(V))  #Std of parameters
R=V/(std %o% std) #Correlations.
fit$R=R; fit$std=std
}
return(fit)
}
fit <- solver(unlist(itheta),brownie,TRUE)
print(exp(fit$par))
source('~/Documents/UBC_Courses/Fish_504/Tutorials2011/BrownieSim.R')
## Brownie Model Simulator.
## Random number seed
set.seed(8879)
I <- 3 #Number of years of marking
J <- 4 #Number of years of recaps
m <- 0.5 #true natural mortality
ni <- rpois(I,550)
fj <- rbeta(J,4,12)
#P = recapture probability
#Z = total mortality
#F = fishing mortality
#R = recaptures
P=Z=F=R=matrix(nrow=I,ncol=J)
cj = fj/(m+fj)*(1-exp(-m-fj))
for(i in 1:I)
{
tmp_m=(seq(1,length(i:J),1)-1)*m
tmp_f=c(0,cumsum(fj[i:(J-1)]))
Z[i,i:J]=tmp_m + tmp_f
p=exp(-Z[i,i:J])*cj[i:J]
R[i,i:J]=rmultinom(1,ni[i],p)
}
print(cbind(ni,R))
## End of data generation.
## PARAMETER_SECTION
theta = list(log.m=log(0.5),log.fj=log(fj))# rep(0.1,length=J))
itheta = as.relistable(theta)
## PROCEDURE_SECTION
brownie <- function(theta)
{
with(relist(theta,skeleton=itheta),{
m=exp(log.m)
fj=exp(log.fj)
#compute predicted recaptures given ni
P=Z=F=Rhat=matrix(nrow=I,ncol=J)
cj = fj/(m+fj)*(1-exp(-m-fj))
nll = 0
for(i in 1:I)
{
tmp_m=(seq(1,length(i:J),1)-1)*m
tmp_f=c(0,cumsum(fj[i:(J-1)]))
Z[i,i:J]=tmp_m + tmp_f
p=exp(-Z[i,i:J])*cj[i:J]
Rhat[i,i:J]=ni[i]*p#rmultinom(1,ni[i],p)
nll=nll   +sum(-dpois(R[i,i:J],Rhat[i,i:J],log=TRUE))
#nll=nll+sum(-dmultinom(R[i,i:J],prob=p,log=TRUE))
}
return(nll)
})
}
## Solver routine to estimate parameters.
solver<-function(theta,objfun,hess=FALSE)
{
fit<-optim(theta,objfun,method="BFGS",hessian=hess)
if(hess==TRUE)
{
H=fit$hessian     #Matrix of 2nd derivatives
V=solve(H)        #Variance covariance matrix
std=sqrt(diag(V))  #Std of parameters
R=V/(std %o% std) #Correlations.
fit$R=R; fit$std=std
}
return(fit)
}
fit <- solver(unlist(itheta),brownie,TRUE)
print(exp(fit$par))
## Brownie Model Simulator.
## Random number seed
set.seed(8879)
I <- 3 #Number of years of marking
J <- 4 #Number of years of recaps
m <- 0.5 #true natural mortality
ni <- rpois(I,550)
fj <- rbeta(J,4,12)
#P = recapture probability
#Z = total mortality
#F = fishing mortality
#R = recaptures
P=Z=F=R=matrix(nrow=I,ncol=J)
cj = fj/(m+fj)*(1-exp(-m-fj))
for(i in 1:I)
{
tmp_m=(seq(1,length(i:J),1)-1)*m
tmp_f=c(0,cumsum(fj[i:(J-1)]))
Z[i,i:J]=tmp_m + tmp_f
p=exp(-Z[i,i:J])*cj[i:J]
R[i,i:J]=rmultinom(1,ni[i],p)
}
print(cbind(ni,R))
## End of data generation.
## PARAMETER_SECTION
theta = list(log.m=log(0.5),log.fj=log(fj))# rep(0.1,length=J))
itheta = as.relistable(theta)
## PROCEDURE_SECTION
brownie <- function(theta)
{
with(relist(theta,skeleton=itheta),{
m=exp(log.m)
fj=exp(log.fj)
#compute predicted recaptures given ni
P=Z=F=Rhat=matrix(nrow=I,ncol=J)
cj = fj/(m+fj)*(1-exp(-m-fj))
nll = 0
for(i in 1:I)
{
tmp_m=(seq(1,length(i:J),1)-1)*m
tmp_f=c(0,cumsum(fj[i:(J-1)]))
Z[i,i:J]=tmp_m + tmp_f
p=exp(-Z[i,i:J])*cj[i:J]
Rhat[i,i:J]=ni[i]*p#rmultinom(1,ni[i],p)
#nll=nll   +sum(-dpois(R[i,i:J],Rhat[i,i:J],log=TRUE))
nll=nll+sum(-dmultinom(R[i,i:J],prob=p,log=TRUE))
}
return(nll)
})
}
## Solver routine to estimate parameters.
solver<-function(theta,objfun,hess=FALSE)
{
fit<-optim(theta,objfun,method="BFGS",hessian=hess)
if(hess==TRUE)
{
H=fit$hessian     #Matrix of 2nd derivatives
V=solve(H)        #Variance covariance matrix
std=sqrt(diag(V))  #Std of parameters
R=V/(std %o% std) #Correlations.
fit$R=R; fit$std=std
}
return(fit)
}
fit <- solver(unlist(itheta),brownie,TRUE)
print(exp(fit$par))
source('~/Documents/UBC_Courses/Fish_504/ASSIGNMENTS/FISHGROWTH/GrowthSim.R')
source('~/Documents/UBC_Courses/Fish_504/ASSIGNMENTS/FISHGROWTH/vonB.R')
dir()
source('~/Documents/UBC_Courses/Fish_504/ASSIGNMENTS/FISHGROWTH/vonB.R')
fit$par
iF<-read.table(pipe("pbpaste"))
matplot(iF)
F<-read.table(pipe("pbpaste"))
matlines(F)
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
## Testing some Ideas for a length Transistion Matrix for#
## a Humpback Chub assessment based on statistical catch-at-length.#
#
## Note that the pgamma function is closely related to the #
## incomplete gamma function (which is used in ADMB cumd_gamma() ).#
## the incomplete gamma function is available in the package#
## zipfR as Igamma(a, x)#
#
## pgamma(x, a, b=1) is equivalent to Igamma(a, x)/gamma(a)#
#
require(zipfR)#
#
## Growth parameters#
linf	<- 40.0#
k		<- 0.25#
beta	<- 0.75#
n		<- 35	#number of intervals#
#
#
## Bin intervals (mm)#
x	<- seq(5.0, 1.0*linf, length=n+1)#
d	<- 0.5*(x[2]-x[1])#
xp	<- seq(x[1]+d, by=2*d, length=n)#
#
dl	<- (linf-xp)*(1-exp(-k))#
alpha <- dl/beta*6/12#
P	<- matrix(0, nrow=n, ncol=n)#
for(i in 1:n)#
{#
	dx = x-x[i]+d#
	print(dx)#
	z <- Igamma(alpha[i], dx)#-Igamma(alpha[i], dx-d)#
	print(z)#
	P[i-1,] <- diff(z)/sum(diff(z)) #
#
}#
matplot(xp, t(P), type="l")#
#
f = rep(0, length=n)#
f[7] = 10#
#par(mfcol=c(1, 3))#
plot(xp, f, type="S", ylim=c(0, 12), lwd=2, xlab="Size interval (cm)", ylab="Frequency")#
for(i in 2:4)#
{#
	f=f%*%P#
	lines(xp+(i-2)*3/12, f, type="S", col=i, lwd=2)#
}#
legend("top",c("Age 0", "Age 0.5", "Age 1.0", "Age 1.5"), lty=1, col=1:4, ncol=4, lwd=2, bty="n")#
dev.copy2pdf(file="../FIGS/fig:lengthTransition.pdf")
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
## Testing some Ideas for a length Transistion Matrix for#
## a Humpback Chub assessment based on statistical catch-at-length.#
#
## Note that the pgamma function is closely related to the #
## incomplete gamma function (which is used in ADMB cumd_gamma() ).#
## the incomplete gamma function is available in the package#
## zipfR as Igamma(a, x)#
#
## pgamma(x, a, b=1) is equivalent to Igamma(a, x)/gamma(a)#
#
require(zipfR)#
#
## Growth parameters#
linf	<- 40.0#
k		<- 0.25#
beta	<- 0.75#
n		<- 35	#number of intervals#
#
#
## Bin intervals (mm)#
x	<- seq(5.0, 1.0*linf, length=n+1)#
d	<- 0.5*(x[2]-x[1])#
xp	<- seq(x[1]+d, by=2*d, length=n)#
#
dl	<- (linf-xp)*(1-exp(-k))#
alpha <- dl/beta*6/12#
P	<- matrix(0, nrow=n, ncol=n)#
for(i in 1:n)#
{#
	dx = x-x[i]+d#
	print(dx)#
	z <- Igamma(alpha[i], dx)#-Igamma(alpha[i], dx-d)#
	print(z)#
	P[i-1,] <- diff(z)/sum(diff(z)) #
#
}#
matplot(xp, t(P), type="l")#
#
f = rep(0, length=n)#
f[7] = 10#
#par(mfcol=c(1, 3))#
plot(xp, f, type="S", ylim=c(0, 12), lwd=2, xlab="Size interval (cm)", ylab="Frequency")#
for(i in 2:4)#
{#
	f=f%*%P#
	lines(xp+(i-2)*3/12, f, type="S", col=i, lwd=2)#
}#
legend("top",c("Age 0", "Age 0.5", "Age 1.0", "Age 1.5"), lty=1, col=1:4, ncol=4, lwd=2, bty="n")#
dev.copy2pdf(file="../FIGS/fig:lengthTransition.pdf")#
#
#
#Population model with constant recruitment.#
N = rep(0, length=n)#
R = rep(0, length=n)#
R = 100*dgamma(xp, 4, 1)
R
plot(R)
plot(xp,dgamma(xp,3,2))
plot(xp,dgamma(xp,3,0.75))
plot(xp,dgamma(xp,3,shap=0.75))
plot(xp,dgamma(xp,3,rate=0.75))
plot(xp,dgamma(xp,3,rate=1.75))
plot(xp,dgamma(xp,3,shape=1.75))
plot(xp,dgamma(xp,10,shape=1.75))
?dgamma
a = 10*0.75
a
plot(xp,dgamma(xp,a,scale=0.75))
plot(xp,dgamma(xp,a,scale=1.75))
plot(xp,dgamma(xp,a,scale=20.75))
plot(xp,dgamma(xp,a,scale=2.75))
plot(xp,dgamma(xp,2,scale=2.75))
plot(xp,dgamma(xp,2,scale=1.75))
plot(xp,dgamma(xp,a,scale=.15))
plot(xp,dgamma(xp,10,scale=.15))
plot(xp,dgamma(xp,10,scale=.5))
plot(xp,dgamma(xp,10,scale=1.5))
plot(xp,dgamma(xp,100,scale=1.5))
plot(xp,dgamma(xp,20,scale=1.5))
plot(xp,dgamma(xp,10,scale=1.5))
plot(xp,dgamma(xp,10,scale=2.5))
1/0.75
1.3
xp
mu=10
cv=0.1
cv=0.01
s=0.01/10
s
a=10/s
a
plot(xp,dgamma(xp,a,s))
s=0.1/10
s
a=10/s
a
plot(xp,dgamma(xp,a,s))
plot(xp,dgamma(xp,a,scale=s))
plot(xp,dgamma(xp,a,scale=s),type="l")
s=0.2/10
a=10/s
s=0.2/10
plot(xp,dgamma(xp,a,scale=s),type="l")
s=0.5/10
a=10/s
plot(xp,dgamma(xp,a,scale=s),type="l")
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
## Testing some Ideas for a length Transistion Matrix for#
## a Humpback Chub assessment based on statistical catch-at-length.#
#
## Note that the pgamma function is closely related to the #
## incomplete gamma function (which is used in ADMB cumd_gamma() ).#
## the incomplete gamma function is available in the package#
## zipfR as Igamma(a, x)#
#
## pgamma(x, a, b=1) is equivalent to Igamma(a, x)/gamma(a)#
#
require(zipfR)#
#
## Growth parameters#
linf	<- 40.0#
k		<- 0.25#
beta	<- 0.75#
n		<- 35	#number of intervals#
#
#
## Bin intervals (mm)#
x	<- seq(5.0, 1.0*linf, length=n+1)#
d	<- 0.5*(x[2]-x[1])#
xp	<- seq(x[1]+d, by=2*d, length=n)#
#
dl	<- (linf-xp)*(1-exp(-k))#
alpha <- dl/beta*6/12#
P	<- matrix(0, nrow=n, ncol=n)#
for(i in 1:n)#
{#
	dx = x-x[i]+d#
	print(dx)#
	z <- Igamma(alpha[i], dx)#-Igamma(alpha[i], dx-d)#
	print(z)#
	P[i-1,] <- diff(z)/sum(diff(z)) #
#
}#
matplot(xp, t(P), type="l")#
#
f = rep(0, length=n)#
f[7] = 10#
#par(mfcol=c(1, 3))#
plot(xp, f, type="S", ylim=c(0, 12), lwd=2, xlab="Size interval (cm)", ylab="Frequency")#
for(i in 2:4)#
{#
	f=f%*%P#
	lines(xp+(i-2)*3/12, f, type="S", col=i, lwd=2)#
}#
legend("top",c("Age 0", "Age 0.5", "Age 1.0", "Age 1.5"), lty=1, col=1:4, ncol=4, lwd=2, bty="n")#
dev.copy2pdf(file="../FIGS/fig:lengthTransition.pdf")#
#
#
#Population model with constant recruitment.#
N = rep(0, length=n)#
R = rep(0, length=n)#
#
R = 100*dgamma(xp, 0.5, scale=0.5/10)
R
plot(R)
a
s=0.5/10
s
a=10/s
a
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
## Testing some Ideas for a length Transistion Matrix for#
## a Humpback Chub assessment based on statistical catch-at-length.#
#
## Note that the pgamma function is closely related to the #
## incomplete gamma function (which is used in ADMB cumd_gamma() ).#
## the incomplete gamma function is available in the package#
## zipfR as Igamma(a, x)#
#
## pgamma(x, a, b=1) is equivalent to Igamma(a, x)/gamma(a)#
#
require(zipfR)#
#
## Growth parameters#
linf	<- 40.0#
k		<- 0.25#
beta	<- 0.75#
n		<- 35	#number of intervals#
#
#
## Bin intervals (mm)#
x	<- seq(5.0, 1.0*linf, length=n+1)#
d	<- 0.5*(x[2]-x[1])#
xp	<- seq(x[1]+d, by=2*d, length=n)#
#
dl	<- (linf-xp)*(1-exp(-k))#
alpha <- dl/beta*6/12#
P	<- matrix(0, nrow=n, ncol=n)#
for(i in 1:n)#
{#
	dx = x-x[i]+d#
	print(dx)#
	z <- Igamma(alpha[i], dx)#-Igamma(alpha[i], dx-d)#
	print(z)#
	P[i-1,] <- diff(z)/sum(diff(z)) #
#
}#
matplot(xp, t(P), type="l")#
#
f = rep(0, length=n)#
f[7] = 10#
#par(mfcol=c(1, 3))#
plot(xp, f, type="S", ylim=c(0, 12), lwd=2, xlab="Size interval (cm)", ylab="Frequency")#
for(i in 2:4)#
{#
	f=f%*%P#
	lines(xp+(i-2)*3/12, f, type="S", col=i, lwd=2)#
}#
legend("top",c("Age 0", "Age 0.5", "Age 1.0", "Age 1.5"), lty=1, col=1:4, ncol=4, lwd=2, bty="n")#
dev.copy2pdf(file="../FIGS/fig:lengthTransition.pdf")#
#
#
#Population model with constant recruitment.#
N = rep(0, length=n)#
R = rep(0, length=n)#
#
R = 100*dgamma(xp, 200, scale=0.5/10)
plot(R)
sum(R)
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
## Testing some Ideas for a length Transistion Matrix for#
## a Humpback Chub assessment based on statistical catch-at-length.#
#
## Note that the pgamma function is closely related to the #
## incomplete gamma function (which is used in ADMB cumd_gamma() ).#
## the incomplete gamma function is available in the package#
## zipfR as Igamma(a, x)#
#
## pgamma(x, a, b=1) is equivalent to Igamma(a, x)/gamma(a)#
#
require(zipfR)#
#
## Growth parameters#
linf	<- 40.0#
k		<- 0.25#
beta	<- 0.75#
n		<- 35	#number of intervals#
#
#
## Bin intervals (mm)#
x	<- seq(5.0, 1.0*linf, length=n+1)#
d	<- 0.5*(x[2]-x[1])#
xp	<- seq(x[1]+d, by=2*d, length=n)#
#
dl	<- (linf-xp)*(1-exp(-k))#
alpha <- dl/beta*6/12#
P	<- matrix(0, nrow=n, ncol=n)#
for(i in 1:n)#
{#
	dx = x-x[i]+d#
	print(dx)#
	z <- Igamma(alpha[i], dx)#-Igamma(alpha[i], dx-d)#
	print(z)#
	P[i-1,] <- diff(z)/sum(diff(z)) #
#
}#
matplot(xp, t(P), type="l")#
#
f = rep(0, length=n)#
f[7] = 10#
#par(mfcol=c(1, 3))#
plot(xp, f, type="S", ylim=c(0, 12), lwd=2, xlab="Size interval (cm)", ylab="Frequency")#
for(i in 2:4)#
{#
	f=f%*%P#
	lines(xp+(i-2)*3/12, f, type="S", col=i, lwd=2)#
}#
legend("top",c("Age 0", "Age 0.5", "Age 1.0", "Age 1.5"), lty=1, col=1:4, ncol=4, lwd=2, bty="n")#
dev.copy2pdf(file="../FIGS/fig:lengthTransition.pdf")#
#
#
#Population model with constant recruitment.#
N = rep(0, length=n)#
R = rep(0, length=n)#
#
r = dgamma(xp, 200, scale=0.5/10)/sum(dgamma(xp, 200, scale=0.5/10))#
R = 100 * r
R
plot(R)
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
## Testing some Ideas for a length Transistion Matrix for#
## a Humpback Chub assessment based on statistical catch-at-length.#
#
## Note that the pgamma function is closely related to the #
## incomplete gamma function (which is used in ADMB cumd_gamma() ).#
## the incomplete gamma function is available in the package#
## zipfR as Igamma(a, x)#
#
## pgamma(x, a, b=1) is equivalent to Igamma(a, x)/gamma(a)#
#
require(zipfR)#
#
## Growth parameters#
linf	<- 40.0#
k		<- 0.25#
beta	<- 0.75#
n		<- 35	#number of intervals#
#
#
## Bin intervals (mm)#
x	<- seq(5.0, 1.0*linf, length=n+1)#
d	<- 0.5*(x[2]-x[1])#
xp	<- seq(x[1]+d, by=2*d, length=n)#
#
dl	<- (linf-xp)*(1-exp(-k))#
alpha <- dl/beta*6/12#
P	<- matrix(0, nrow=n, ncol=n)#
for(i in 1:n)#
{#
	dx = x-x[i]+d#
	print(dx)#
	z <- Igamma(alpha[i], dx)#-Igamma(alpha[i], dx-d)#
	print(z)#
	P[i-1,] <- diff(z)/sum(diff(z)) #
#
}#
matplot(xp, t(P), type="l")#
#
f = rep(0, length=n)#
f[7] = 10#
#par(mfcol=c(1, 3))#
plot(xp, f, type="S", ylim=c(0, 12), lwd=2, xlab="Size interval (cm)", ylab="Frequency")#
for(i in 2:4)#
{#
	f=f%*%P#
	lines(xp+(i-2)*3/12, f, type="S", col=i, lwd=2)#
}#
legend("top",c("Age 0", "Age 0.5", "Age 1.0", "Age 1.5"), lty=1, col=1:4, ncol=4, lwd=2, bty="n")#
dev.copy2pdf(file="../FIGS/fig:lengthTransition.pdf")#
#
#
#Population model with constant recruitment.#
N = rep(0, length=n)#
R = rep(0, length=n)#
#
r = dgamma(xp, 200, scale=0.5/10)/sum(dgamma(xp, 200, scale=0.5/10))#
R = 100 * r#
for(i in 1:10)#
{#
	N = N*exp(-0.2)+R#
	plot(N, type="h")#
}
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
## Testing some Ideas for a length Transistion Matrix for#
## a Humpback Chub assessment based on statistical catch-at-length.#
#
## Note that the pgamma function is closely related to the #
## incomplete gamma function (which is used in ADMB cumd_gamma() ).#
## the incomplete gamma function is available in the package#
## zipfR as Igamma(a, x)#
#
## pgamma(x, a, b=1) is equivalent to Igamma(a, x)/gamma(a)#
#
require(zipfR)#
#
## Growth parameters#
linf	<- 40.0#
k		<- 0.25#
beta	<- 0.75#
n		<- 35	#number of intervals#
#
#
## Bin intervals (mm)#
x	<- seq(5.0, 1.0*linf, length=n+1)#
d	<- 0.5*(x[2]-x[1])#
xp	<- seq(x[1]+d, by=2*d, length=n)#
#
dl	<- (linf-xp)*(1-exp(-k))#
alpha <- dl/beta*6/12#
P	<- matrix(0, nrow=n, ncol=n)#
for(i in 1:n)#
{#
	dx = x-x[i]+d#
	print(dx)#
	z <- Igamma(alpha[i], dx)#-Igamma(alpha[i], dx-d)#
	print(z)#
	P[i-1,] <- diff(z)/sum(diff(z)) #
#
}#
matplot(xp, t(P), type="l")#
#
f = rep(0, length=n)#
f[7] = 10#
#par(mfcol=c(1, 3))#
plot(xp, f, type="S", ylim=c(0, 12), lwd=2, xlab="Size interval (cm)", ylab="Frequency")#
for(i in 2:4)#
{#
	f=f%*%P#
	lines(xp+(i-2)*3/12, f, type="S", col=i, lwd=2)#
}#
legend("top",c("Age 0", "Age 0.5", "Age 1.0", "Age 1.5"), lty=1, col=1:4, ncol=4, lwd=2, bty="n")#
dev.copy2pdf(file="../FIGS/fig:lengthTransition.pdf")#
#
#
#Population model with constant recruitment.#
N = rep(0, length=n)#
R = rep(0, length=n)#
#
r = dgamma(xp, 200, scale=0.5/10)/sum(dgamma(xp, 200, scale=0.5/10))#
R = 100 * r#
for(i in 1:10)#
{#
	N = N*exp(-0.2)%*%P +R#
	plot(N, type="h")#
}
R%*%P
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
## Testing some Ideas for a length Transistion Matrix for#
## a Humpback Chub assessment based on statistical catch-at-length.#
#
## Note that the pgamma function is closely related to the #
## incomplete gamma function (which is used in ADMB cumd_gamma() ).#
## the incomplete gamma function is available in the package#
## zipfR as Igamma(a, x)#
#
## pgamma(x, a, b=1) is equivalent to Igamma(a, x)/gamma(a)#
#
require(zipfR)#
#
## Growth parameters#
linf	<- 40.0#
k		<- 0.25#
beta	<- 0.75#
n		<- 35	#number of intervals#
#
#
## Bin intervals (mm)#
x	<- seq(5.0, 1.0*linf, length=n+1)#
d	<- 0.5*(x[2]-x[1])#
xp	<- seq(x[1]+d, by=2*d, length=n)#
#
dl	<- (linf-xp)*(1-exp(-k))#
alpha <- dl/beta*6/12#
P	<- matrix(0, nrow=n, ncol=n)#
for(i in 1:n)#
{#
	dx = x-x[i]+d#
	print(dx)#
	z <- Igamma(alpha[i], dx)#-Igamma(alpha[i], dx-d)#
	print(z)#
	P[i-1,] <- diff(z)/sum(diff(z)) #
#
}#
matplot(xp, t(P), type="l")#
#
f = rep(0, length=n)#
f[7] = 10#
#par(mfcol=c(1, 3))#
plot(xp, f, type="S", ylim=c(0, 12), lwd=2, xlab="Size interval (cm)", ylab="Frequency")#
for(i in 2:4)#
{#
	f=f%*%P#
	lines(xp+(i-2)*3/12, f, type="S", col=i, lwd=2)#
}#
legend("top",c("Age 0", "Age 0.5", "Age 1.0", "Age 1.5"), lty=1, col=1:4, ncol=4, lwd=2, bty="n")#
dev.copy2pdf(file="../FIGS/fig:lengthTransition.pdf")#
#
#
#Population model with constant recruitment.#
N = rep(0, length=n)#
R = rep(0, length=n)#
#
r = dgamma(xp, 200, scale=0.5/10)/sum(dgamma(xp, 200, scale=0.5/10))#
R = 100 * r#
for(i in 1:10)#
{#
	N = as.vector((N*exp(-0.2))%*%P) +R#
	plot(N, type="h")#
}
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
## Testing some Ideas for a length Transistion Matrix for#
## a Humpback Chub assessment based on statistical catch-at-length.#
#
## Note that the pgamma function is closely related to the #
## incomplete gamma function (which is used in ADMB cumd_gamma() ).#
## the incomplete gamma function is available in the package#
## zipfR as Igamma(a, x)#
#
## pgamma(x, a, b=1) is equivalent to Igamma(a, x)/gamma(a)#
#
require(zipfR)#
#
## Growth parameters#
linf	<- 40.0#
k		<- 0.25#
beta	<- 0.75#
n		<- 35	#number of intervals#
#
#
## Bin intervals (mm)#
x	<- seq(5.0, 1.0*linf, length=n+1)#
d	<- 0.5*(x[2]-x[1])#
xp	<- seq(x[1]+d, by=2*d, length=n)#
#
dl	<- (linf-xp)*(1-exp(-k))#
alpha <- dl/beta*6/12#
P	<- matrix(0, nrow=n, ncol=n)#
for(i in 1:n)#
{#
	dx = x-x[i]+d#
	print(dx)#
	z <- Igamma(alpha[i], dx)#-Igamma(alpha[i], dx-d)#
	print(z)#
	P[i-1,] <- diff(z)/sum(diff(z)) #
#
}#
matplot(xp, t(P), type="l")#
#
f = rep(0, length=n)#
f[7] = 10#
#par(mfcol=c(1, 3))#
plot(xp, f, type="S", ylim=c(0, 12), lwd=2, xlab="Size interval (cm)", ylab="Frequency")#
for(i in 2:4)#
{#
	f=f%*%P#
	lines(xp+(i-2)*3/12, f, type="S", col=i, lwd=2)#
}#
legend("top",c("Age 0", "Age 0.5", "Age 1.0", "Age 1.5"), lty=1, col=1:4, ncol=4, lwd=2, bty="n")#
dev.copy2pdf(file="../FIGS/fig:lengthTransition.pdf")#
#
#
#Population model with constant recruitment.#
N = rep(0, length=n)#
R = rep(0, length=n)#
#
r = dgamma(xp, 200, scale=0.5/10)/sum(dgamma(xp, 200, scale=0.5/10))#
R = 100 * r#
for(i in 1:50)#
{#
	N = as.vector((N*exp(-0.4))%*%P) +R#
	plot(N, type="h")#
}
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
## Testing some Ideas for a length Transistion Matrix for#
## a Humpback Chub assessment based on statistical catch-at-length.#
#
## Note that the pgamma function is closely related to the #
## incomplete gamma function (which is used in ADMB cumd_gamma() ).#
## the incomplete gamma function is available in the package#
## zipfR as Igamma(a, x)#
#
## pgamma(x, a, b=1) is equivalent to Igamma(a, x)/gamma(a)#
#
require(zipfR)#
#
## Growth parameters#
linf	<- 40.0#
k		<- 0.25#
beta	<- 0.75#
n		<- 35	#number of intervals#
#
#
## Bin intervals (mm)#
x	<- seq(5.0, 1.0*linf, length=n+1)#
d	<- 0.5*(x[2]-x[1])#
xp	<- seq(x[1]+d, by=2*d, length=n)#
#
dl	<- (linf-xp)*(1-exp(-k))#
alpha <- dl/beta*6/12#
P	<- matrix(0, nrow=n, ncol=n)#
for(i in 1:n)#
{#
	dx = x-x[i]+d#
	print(dx)#
	z <- Igamma(alpha[i], dx)#-Igamma(alpha[i], dx-d)#
	print(z)#
	P[i-1,] <- diff(z)/sum(diff(z)) #
#
}#
matplot(xp, t(P), type="l")#
#
f = rep(0, length=n)#
f[7] = 10#
#par(mfcol=c(1, 3))#
plot(xp, f, type="S", ylim=c(0, 12), lwd=2, xlab="Size interval (cm)", ylab="Frequency")#
for(i in 2:4)#
{#
	f=f%*%P#
	lines(xp+(i-2)*3/12, f, type="S", col=i, lwd=2)#
}#
legend("top",c("Age 0", "Age 0.5", "Age 1.0", "Age 1.5"), lty=1, col=1:4, ncol=4, lwd=2, bty="n")#
dev.copy2pdf(file="../FIGS/fig:lengthTransition.pdf")#
#
#
#Population model with constant recruitment.#
N = rep(0, length=n)#
R = rep(0, length=n)#
#
r = dgamma(xp, 200, scale=0.5/10)/sum(dgamma(xp, 200, scale=0.5/10))#
R = 100 * r#
plot(xp,R, type="l")#
for(i in 1:50)#
{#
	N = as.vector((N*exp(-0.4))%*%P) +R#
	lines(xp, N, type="h")#
}
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
## Testing some Ideas for a length Transistion Matrix for#
## a Humpback Chub assessment based on statistical catch-at-length.#
#
## Note that the pgamma function is closely related to the #
## incomplete gamma function (which is used in ADMB cumd_gamma() ).#
## the incomplete gamma function is available in the package#
## zipfR as Igamma(a, x)#
#
## pgamma(x, a, b=1) is equivalent to Igamma(a, x)/gamma(a)#
#
require(zipfR)#
#
## Growth parameters#
linf	<- 40.0#
k		<- 0.25#
beta	<- 0.75#
n		<- 35	#number of intervals#
#
#
## Bin intervals (mm)#
x	<- seq(5.0, 1.0*linf, length=n+1)#
d	<- 0.5*(x[2]-x[1])#
xp	<- seq(x[1]+d, by=2*d, length=n)#
#
dl	<- (linf-xp)*(1-exp(-k))#
alpha <- dl/beta*6/12#
P	<- matrix(0, nrow=n, ncol=n)#
for(i in 1:n)#
{#
	dx = x-x[i]+d#
	print(dx)#
	z <- Igamma(alpha[i], dx)#-Igamma(alpha[i], dx-d)#
	print(z)#
	P[i-1,] <- diff(z)/sum(diff(z)) #
#
}#
matplot(xp, t(P), type="l")#
#
f = rep(0, length=n)#
f[7] = 10#
#par(mfcol=c(1, 3))#
plot(xp, f, type="S", ylim=c(0, 12), lwd=2, xlab="Size interval (cm)", ylab="Frequency")#
for(i in 2:4)#
{#
	f=f%*%P#
	lines(xp+(i-2)*3/12, f, type="S", col=i, lwd=2)#
}#
legend("top",c("Age 0", "Age 0.5", "Age 1.0", "Age 1.5"), lty=1, col=1:4, ncol=4, lwd=2, bty="n")#
dev.copy2pdf(file="../FIGS/fig:lengthTransition.pdf")#
#
#
#Population model with constant recruitment.#
N = rep(0, length=n)#
R = rep(0, length=n)#
#
r = dgamma(xp, 200, scale=0.5/10)/sum(dgamma(xp, 200, scale=0.5/10))#
R = 100 * r#
plot(xp,R, type="l")#
for(i in 1:50)#
{#
	N = as.vector((N*exp(-0.4))%*%P) +R#
	lines(xp, N, type="l")#
}
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
## Testing some Ideas for a length Transistion Matrix for#
## a Humpback Chub assessment based on statistical catch-at-length.#
#
## Note that the pgamma function is closely related to the #
## incomplete gamma function (which is used in ADMB cumd_gamma() ).#
## the incomplete gamma function is available in the package#
## zipfR as Igamma(a, x)#
#
## pgamma(x, a, b=1) is equivalent to Igamma(a, x)/gamma(a)#
#
require(zipfR)#
#
## Growth parameters#
linf	<- 40.0#
k		<- 0.25#
beta	<- 0.75#
n		<- 35	#number of intervals#
#
#
## Bin intervals (mm)#
x	<- seq(5.0, 1.0*linf, length=n+1)#
d	<- 0.5*(x[2]-x[1])#
xp	<- seq(x[1]+d, by=2*d, length=n)#
#
dl	<- (linf-xp)*(1-exp(-k))#
alpha <- dl/beta*6/12#
P	<- matrix(0, nrow=n, ncol=n)#
for(i in 1:n)#
{#
	dx = x-x[i]+d#
	print(dx)#
	z <- Igamma(alpha[i], dx)#-Igamma(alpha[i], dx-d)#
	print(z)#
	P[i-1,] <- diff(z)/sum(diff(z)) #
#
}#
matplot(xp, t(P), type="l")#
#
f = rep(0, length=n)#
f[7] = 10#
#par(mfcol=c(1, 3))#
plot(xp, f, type="S", ylim=c(0, 12), lwd=2, xlab="Size interval (cm)", ylab="Frequency")#
for(i in 2:4)#
{#
	f=f%*%P#
	lines(xp+(i-2)*3/12, f, type="S", col=i, lwd=2)#
}#
legend("top",c("Age 0", "Age 0.5", "Age 1.0", "Age 1.5"), lty=1, col=1:4, ncol=4, lwd=2, bty="n")#
dev.copy2pdf(file="../FIGS/fig:lengthTransition.pdf")#
#
#
#Population model with constant recruitment.#
N = rep(0, length=n)#
R = rep(0, length=n)#
#
r = dgamma(xp, 200, scale=0.5/10)/sum(dgamma(xp, 200, scale=0.5/10))#
R = 100 * r#
plot(xp,R, type="l")#
for(i in 1:50)#
{#
	N = as.vector((N*exp(-0.9))%*%P) +R#
	lines(xp, N, type="l")#
}
setwd('/Users/stevenmartell/Documents/CONSULTING/HumpbackChub/HBC_2011_Assessment/R')
## Testing some Ideas for a length Transistion Matrix for#
## a Humpback Chub assessment based on statistical catch-at-length.#
#
## Note that the pgamma function is closely related to the #
## incomplete gamma function (which is used in ADMB cumd_gamma() ).#
## the incomplete gamma function is available in the package#
## zipfR as Igamma(a, x)#
#
## pgamma(x, a, b=1) is equivalent to Igamma(a, x)/gamma(a)#
#
require(zipfR)#
#
## Growth parameters#
linf	<- 40.0#
k		<- 0.25#
beta	<- 0.75#
n		<- 35	#number of intervals#
#
#
## Bin intervals (mm)#
x	<- seq(5.0, 1.0*linf, length=n+1)#
d	<- 0.5*(x[2]-x[1])#
xp	<- seq(x[1]+d, by=2*d, length=n)#
#
dl	<- (linf-xp)*(1-exp(-k))#
alpha <- dl/beta*6/12#
P	<- matrix(0, nrow=n, ncol=n)#
for(i in 1:n)#
{#
	dx = x-x[i]+d#
	print(dx)#
	z <- Igamma(alpha[i], dx)#-Igamma(alpha[i], dx-d)#
	print(z)#
	P[i-1,] <- diff(z)/sum(diff(z)) #
#
}#
matplot(xp, t(P), type="l")#
#
f = rep(0, length=n)#
f[7] = 10#
#par(mfcol=c(1, 3))#
plot(xp, f, type="S", ylim=c(0, 12), lwd=2, xlab="Size interval (cm)", ylab="Frequency")#
for(i in 2:4)#
{#
	f=f%*%P#
	lines(xp+(i-2)*3/12, f, type="S", col=i, lwd=2)#
}#
legend("top",c("Age 0", "Age 0.5", "Age 1.0", "Age 1.5"), lty=1, col=1:4, ncol=4, lwd=2, bty="n")#
dev.copy2pdf(file="../FIGS/fig:lengthTransition.pdf")#
#
#
#Population model with constant recruitment.#
N = rep(0, length=n)#
R = rep(0, length=n)#
#
r = dgamma(xp, 200, scale=0.5/10)/sum(dgamma(xp, 200, scale=0.5/10))#
R = 100 * r#
plot(xp,R, type="l")#
for(i in 1:50)#
{#
	N = as.vector((N*exp(-0.5))%*%P) +R#
	lines(xp, N, type="l")#
}
colSums(P)
plot(colSums(P))
